     1                                  ;
     2                                  ; File:
     3                                  ;                            boot.asm
     4                                  ; Description:
     5                                  ;                           DOS-C boot
     6                                  ;
     7                                  ;                       Copyright (c) 1997;
     8                                  ;                           Svante Frey
     9                                  ;                       All Rights Reserved
    10                                  ;
    11                                  ; This file is part of DOS-C.
    12                                  ;
    13                                  ; DOS-C is free software; you can redistribute it and/or
    14                                  ; modify it under the terms of the GNU General Public License
    15                                  ; as published by the Free Software Foundation; either version
    16                                  ; 2, or (at your option) any later version.
    17                                  ;
    18                                  ; DOS-C is distributed in the hope that it will be useful, but
    19                                  ; WITHOUT ANY WARRANTY; without even the implied warranty of
    20                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    21                                  ; the GNU General Public License for more details.
    22                                  ;
    23                                  ; You should have received a copy of the GNU General Public
    24                                  ; License along with DOS-C; see the file COPYING.  If not,
    25                                  ; write to the Free Software Foundation, 675 Mass Ave,
    26                                  ; Cambridge, MA 02139, USA.
    27                                  ;
    28                                  ;
    29                                  ;       +--------+ 1FE0:7E00
    30                                  ;       |BOOT SEC|
    31                                  ;       |RELOCATE|
    32                                  ;       |--------| 1FE0:7C00
    33                                  ;       |LBA PKT |
    34                                  ;       |--------| 1FE0:7BC0
    35                                  ;       |--------| 1FE0:7BA0
    36                                  ;       |BS STACK|
    37                                  ;       |--------|
    38                                  ;       |4KBRDBUF| used to avoid crossing 64KB DMA boundary
    39                                  ;       |--------| 1FE0:63A0
    40                                  ;       |        |
    41                                  ;       |--------| 1FE0:3000
    42                                  ;       | CLUSTER|
    43                                  ;       |  LIST  |
    44                                  ;       |--------| 1FE0:2000
    45                                  ;       |        |
    46                                  ;       |--------| 0000:7E00
    47                                  ;       |BOOT SEC| overwritten by max 128k FAT buffer
    48                                  ;       |ORIGIN  | and later by max 134k loaded kernel
    49                                  ;       |--------| 0000:7C00
    50                                  ;       |        |
    51                                  ;       |--------|
    52                                  ;       |KERNEL  | also used as max 128k FAT buffer
    53                                  ;       |LOADED  | before kernel loading starts
    54                                  ;       |--------| 0060:0000
    55                                  ;       |        |
    56                                  ;       +--------+
    57                                  
    58                                  
    59                                  ;%define ISFAT12         1
    60                                  ;%define ISFAT16         1
    61                                  
    62                                  
    63                                  segment .text
    64                                  
    65                                  %define BASE            0x7c00
    66                                  
    67                                                  org     BASE
    68                                  
    69 00000000 EB3C                    Entry:          jmp     short real_start
    70 00000002 90                                      nop
    71                                  
    72                                  ;       bp is initialized to 7c00h
    73                                  %define bsOemName       bp+0x03      ; OEM label
    74                                  %define bsBytesPerSec   bp+0x0b      ; bytes/sector
    75                                  %define bsSecPerClust   bp+0x0d      ; sectors/allocation unit
    76                                  %define bsResSectors    bp+0x0e      ; # reserved sectors
    77                                  %define bsFATs          bp+0x10      ; # of fats
    78                                  %define bsRootDirEnts   bp+0x11      ; # of root dir entries
    79                                  %define bsSectors       bp+0x13      ; # sectors total in image
    80                                  %define bsMedia         bp+0x15      ; media descrip: fd=2side9sec, etc...
    81                                  %define sectPerFat      bp+0x16      ; # sectors in a fat
    82                                  %define sectPerTrack    bp+0x18      ; # sectors/track
    83                                  %define nHeads          bp+0x1a      ; # heads
    84                                  %define nHidden         bp+0x1c      ; # hidden sectors
    85                                  %define nSectorHuge     bp+0x20      ; # sectors if > 65536
    86                                  %define drive           bp+0x24      ; drive number
    87                                  %define extBoot         bp+0x26      ; extended boot signature
    88                                  %define volid           bp+0x27
    89                                  %define vollabel        bp+0x2b
    90                                  %define filesys         bp+0x36
    91                                  
    92                                  %define LOADSEG         0x0060
    93                                  
    94                                  %define FATBUF          0x2000          ; offset of temporary buffer for FAT
    95                                                                          ; chain
    96                                  
    97                                  ;       Some extra variables
    98                                  
    99                                  ;%define StoreSI         bp+3h          ;temp store
   100                                  
   101                                  ;-----------------------------------------------------------------------
   102                                  
   103 00000003 00<rept>                                times   0x3E-$+$$ db 0
   104                                  
   105                                  ; using bp-Entry+loadseg_xxx generates smaller code than using just
   106                                  ; loadseg_xxx, where bp is initialized to Entry, so bp-Entry equals 0
   107                                  %define loadsegoff_60   bp-Entry+loadseg_off
   108                                  %define loadseg_60      bp-Entry+loadseg_seg
   109                                  
   110                                  %define LBA_PACKET       bp-0x40
   111                                  %define LBA_SIZE       word [LBA_PACKET]    ; size of packet, should be 10h
   112                                  %define LBA_SECNUM     word [LBA_PACKET+2]  ; number of sectors to read
   113                                  %define LBA_OFF        LBA_PACKET+4         ; buffer to read/write to
   114                                  %define LBA_SEG        LBA_PACKET+6
   115                                  %define LBA_SECTOR_0   word [LBA_PACKET+8 ] ; LBA starting sector #
   116                                  %define LBA_SECTOR_16  word [LBA_PACKET+10]
   117                                  %define LBA_SECTOR_32  word [LBA_PACKET+12]
   118                                  %define LBA_SECTOR_48  word [LBA_PACKET+14]
   119                                  
   120                                  %define READBUF 0x63A0 ; max 4KB buffer (min 2KB stack), == stacktop-0x1800
   121                                  %define READADDR_OFF   BP-0x60-0x1804    ; pointer within user buffer
   122                                  %define READADDR_SEG   BP-0x60-0x1802
   123                                  
   124                                  %define PARAMS LBA_PACKET+0x10
   125                                  ;%define RootDirSecs     PARAMS+0x0         ; # of sectors root dir uses
   126                                  
   127                                  %define fat_start       PARAMS+0x2         ; first FAT sector
   128                                  
   129                                  %define root_dir_start  PARAMS+0x6         ; first root directory sector
   130                                  
   131                                  %define data_start      PARAMS+0x0a        ; first data sector
   132                                  
   133                                  
   134                                  ;-----------------------------------------------------------------------
   135                                  ;   ENTRY
   136                                  ;-----------------------------------------------------------------------
   137                                  
   138                                  real_start:
   139 0000003E FA                                      cli
   140 0000003F FC                                      cld
   141 00000040 31C0                                    xor     ax, ax
   142 00000042 8ED8                                    mov     ds, ax
   143 00000044 BD007C                                  mov     bp, BASE
   144                                  
   145                                  
   146                                                                          ; a reset should not be needed here
   147                                  ;               int     0x13            ; reset drive
   148                                  
   149                                  ;               int     0x12            ; get memory available in AX
   150                                  ;               mov     ax, 0x01e0
   151                                  ;               mov     cl, 6           ; move boot sector to higher memory
   152                                  ;               shl     ax, cl
   153                                  ;               sub     ax, 0x07e0
   154                                  
   155 00000047 B8E01F                                  mov     ax, 0x1FE0
   156 0000004A 8EC0                                    mov     es, ax
   157 0000004C 89EE                                    mov     si, bp
   158 0000004E 89EF                                    mov     di, bp
   159 00000050 B90001                                  mov     cx, 0x0100
   160 00000053 F3A5                                    rep     movsw
   161 00000055 EA[5E00]E01F                            jmp     word 0x1FE0:cont
   162                                  
   163 0000005A 0000                    loadseg_off     dw      0
   164 0000005C 6000                    loadseg_seg     dw      LOADSEG
   165                                  
   166                                  cont:
   167 0000005E 8ED8                                    mov     ds, ax
   168 00000060 8ED0                                    mov     ss, ax
   169 00000062 8D66A0                                  lea     sp, [bp-0x60]
   170 00000065 FB                                      sti
   171                                  ;
   172                                  ; Note: some BIOS implementations may not correctly pass drive number
   173                                  ; in DL, however we work around this in SYS.COM by NOP'ing out the use of DL
   174                                  ; (formerly we checked for [drive]==0xff; update sys.c if code moves)
   175                                  ;
   176 00000066 885624                                  mov     [drive], dl     ; rely on BIOS drive number in DL
   177                                  
   178 00000069 C746C01000                              mov     LBA_SIZE, 10h
   179 0000006E C746C20100                              mov     LBA_SECNUM,1    ; initialise LBA packet constants
   180 00000073 8C5EC6                                  mov     word [LBA_SEG],ds
   181 00000076 C746C4A063                              mov     word [LBA_OFF],READBUF
   182                                  
   183                                  
   184                                  ;       GETDRIVEPARMS:  Calculate start of some disk areas.
   185                                  ;
   186 0000007B 8B761C                                  mov     si, word [nHidden]
   187 0000007E 8B7E1E                                  mov     di, word [nHidden+2]
   188 00000081 03760E                                  add     si, word [bsResSectors]
   189 00000084 83D700                                  adc     di, byte 0              ; DI:SI = first FAT sector
   190                                  
   191 00000087 8976D2                                  mov     word [fat_start], si
   192 0000008A 897ED4                                  mov     word [fat_start+2], di
   193                                  
   194 0000008D 8A4610                                  mov     al, [bsFATs]
   195 00000090 98                                      cbw
   196 00000091 F76616                                  mul     word [sectPerFat]       ; DX:AX = total number of FAT sectors
   197                                  
   198 00000094 01C6                                    add     si, ax
   199 00000096 11D7                                    adc     di, dx                  ; DI:SI = first root directory sector
   200 00000098 8976D6                                  mov     word [root_dir_start], si
   201 0000009B 897ED8                                  mov     word [root_dir_start+2], di
   202                                  
   203                                                  ; Calculate how many sectors the root directory occupies.
   204 0000009E 8B5E0B                                  mov     bx, [bsBytesPerSec]
   205 000000A1 B105                                    mov     cl, 5                   ; divide BX by 32
   206 000000A3 D3EB                                    shr     bx, cl                  ; BX = directory entries per sector
   207                                  
   208 000000A5 8B4611                                  mov     ax, [bsRootDirEnts]
   209 000000A8 31D2                                    xor     dx, dx
   210 000000AA F7F3                                    div     bx
   211                                  
   212                                  ;               mov     word [RootDirSecs], ax  ; AX = sectors per root directory
   213 000000AC 50                                      push    ax
   214                                  
   215 000000AD 01C6                                    add     si, ax
   216 000000AF 83D700                                  adc     di, byte 0              ; DI:SI = first data sector
   217                                  
   218 000000B2 8976DA                                  mov     [data_start], si
   219 000000B5 897EDC                                  mov     [data_start+2], di
   220                                  
   221                                  
   222                                  ;       FINDFILE: Searches for the file in the root directory.
   223                                  ;
   224                                  ;       Returns:
   225                                  ;                               AX = first cluster of file
   226                                  
   227                                                  ; First, read the whole root directory
   228                                                  ; into the temporary buffer.
   229                                  
   230 000000B8 8B46D6                                  mov     ax, word [root_dir_start]
   231 000000BB 8B56D8                                  mov     dx, word [root_dir_start+2]
   232 000000BE 5F                                      pop     di                      ; mov     di, word [RootDirSecs]
   233 000000BF C45E5A                                  les     bx, [loadsegoff_60] ; es:bx = 60:0
   234 000000C2 E89500                                  call    readDisk
   235 000000C5 C47E5A                                  les     di, [loadsegoff_60] ; es:di = 60:0
   236                                  
   237                                  
   238                                                  ; Search for KERNEL.SYS file name, and find start cluster.
   239                                  
   240 000000C8 B90B00                  next_entry:     mov     cx, 11
   241 000000CB BE[F101]                                mov     si, filename
   242 000000CE 57                                      push    di
   243 000000CF F3A6                                    repe    cmpsb
   244 000000D1 5F                                      pop     di
   245 000000D2 268B451A                                mov     ax, [es:di+0x1A]; get cluster number from directory entry
   246 000000D6 740B                                    je      ffDone
   247                                  
   248 000000D8 83C720                                  add     di, byte 0x20   ; go to next directory entry
   249 000000DB 26803D00                                cmp     byte [es:di], 0 ; if the first byte of the name is 0,
   250 000000DF 75E7                                    jnz     next_entry      ; there is no more files in the directory
   251                                  
   252 000000E1 7265                                    jc      boot_error      ; fail if not found
   253                                  ffDone:
   254 000000E3 50                                      push    ax              ; store first cluster number
   255                                  
   256                                  
   257                                  ;       GETFATCHAIN:
   258                                  ;
   259                                  ;       Reads the FAT chain and stores it in a temporary buffer in the first
   260                                  ;       64 kb.  The FAT chain is stored an array of 16-bit cluster numbers,
   261                                  ;       ending with 0.
   262                                  ;
   263                                  ;       The file must fit in conventional memory, so it can't be larger than
   264                                  ;       640 kb. The sector size must be at least 512 bytes, so the FAT chain
   265                                  ;       can't be larger than 2.5 KB (655360 / 512 * 2 = 2560).
   266                                  ;
   267                                  ;       Call with:      AX = first cluster in chain
   268                                  
   269 000000E4 C45E5A                                  les     bx, [loadsegoff_60]     ; es:bx=60:0
   270 000000E7 8B7E16                                  mov     di, [sectPerFat]
   271 000000EA 8B46D2                                  mov     ax, word [fat_start]
   272 000000ED 8B56D4                                  mov     dx, word [fat_start+2]
   273 000000F0 E86700                                  call    readDisk
   274 000000F3 58                                      pop     ax                      ; restore first cluster number
   275                                  
   276                                                  ; Set ES:DI to the temporary storage for the FAT chain.
   277 000000F4 1E                                      push    ds
   278 000000F5 07                                      pop     es
   279 000000F6 8E5E5C                                  mov     ds, [loadseg_60]
   280 000000F9 BF0020                                  mov     di, FATBUF
   281                                  
   282 000000FC AB                      next_clust:     stosw                           ; store cluster number
   283 000000FD 89C6                                    mov     si, ax                  ; SI = cluster number
   284                                  
   285                                  %ifdef ISFAT12
   286                                                  ; This is a FAT-12 disk.
   287                                  
   288                                  fat_12:         add     si, si          ; multiply cluster number by 3...
   289                                                  add     si, ax
   290                                                  shr     si, 1           ; ...and divide by 2
   291                                                  lodsw
   292                                  
   293                                                  ; If the cluster number was even, the cluster value is now in
   294                                                  ; bits 0-11 of AX. If the cluster number was odd, the cluster
   295                                                  ; value is in bits 4-15, and must be shifted right 4 bits. If
   296                                                  ; the number was odd, CF was set in the last shift instruction.
   297                                  
   298                                                  jnc     fat_even
   299                                                  mov     cl, 4
   300                                                  shr     ax, cl
   301                                  
   302                                  fat_even:       and     ah, 0x0f        ; mask off the highest 4 bits
   303                                                  cmp     ax, 0x0ff8      ; check for EOF
   304                                                  jb      next_clust      ; continue if not EOF
   305                                  
   306                                  %endif
   307                                  %ifdef ISFAT16
   308                                                  ; This is a FAT-16 disk. The maximal size of a 16-bit FAT
   309                                                  ; is 128 kb, so it may not fit within a single 64 kb segment.
   310                                  
   311 000000FF 8B565C                  fat_16:         mov     dx, [loadseg_60]
   312 00000102 01F6                                    add     si, si          ; multiply cluster number by two
   313 00000104 7303                                    jnc     first_half      ; if overflow...
   314 00000106 80C610                                  add     dh, 0x10        ; ...add 64 kb to segment value
   315                                  
   316 00000109 8EDA                    first_half:     mov     ds, dx          ; DS:SI = pointer to next cluster
   317 0000010B AD                                      lodsw                   ; AX = next cluster
   318                                  
   319 0000010C 3DF8FF                                  cmp     ax, 0xfff8      ; >= FFF8 = 16-bit EOF
   320 0000010F 72EB                                    jb      next_clust      ; continue if not EOF
   321                                  %endif
   322                                  
   323                                  finished:       ; Mark end of FAT chain with 0, so we have a single
   324                                                  ; EOF marker for both FAT-12 and FAT-16 systems.
   325                                  
   326 00000111 31C0                                    xor     ax, ax
   327 00000113 AB                                      stosw
   328                                  
   329 00000114 0E                                      push    cs
   330 00000115 1F                                      pop     ds
   331                                  
   332                                  
   333                                  ;       loadFile: Loads the file into memory, one cluster at a time.
   334                                  
   335 00000116 C45E5A                                  les     bx, [loadsegoff_60]   ; set ES:BX to load address 60:0
   336                                  
   337 00000119 BE0020                                  mov     si, FATBUF      ; set DS:SI to the FAT chain
   338                                  
   339 0000011C AD                      cluster_next:   lodsw                           ; AX = next cluster to read
   340 0000011D 09C0                                    or      ax, ax                  ; EOF?
   341 0000011F 7505                                    jne     load_next               ; no, continue
   342 00000121 88D3                                    mov     bl,dl ; drive (left from readDisk)
   343 00000123 FF6E5A                                  jmp     far [loadsegoff_60]     ; yes, pass control to kernel
   344                                  
   345 00000126 48                      load_next:      dec     ax                      ; cluster numbers start with 2
   346 00000127 48                                      dec     ax
   347                                  
   348 00000128 8B7E0D                                  mov     di, word [bsSecPerClust]
   349 0000012B 81E7FF00                                and     di, 0xff                ; DI = sectors per cluster
   350 0000012F F7E7                                    mul     di
   351 00000131 0346DA                                  add     ax, [data_start]
   352 00000134 1356DC                                  adc     dx, [data_start+2]      ; DX:AX = first sector to read
   353 00000137 E82000                                  call    readDisk
   354 0000013A EBE0                                    jmp     short cluster_next
   355                                  
   356                                  ; shows text after the call to this function.
   357                                  
   358 0000013C 5E                      show:           pop     si
   359 0000013D AC                                      lodsb                           ; get character
   360 0000013E 56                                      push    si                      ; stack up potential return address
   361 0000013F B40E                                    mov     ah,0x0E                 ; show character
   362 00000141 CD10                                    int     0x10                    ; via "TTY" mode
   363 00000143 3C2E                                    cmp     al,'.'                  ; end of string?
   364 00000145 75F5                                    jne     show                    ; until done
   365 00000147 C3                                      ret
   366                                  
   367 00000148 E8F1FF                  boot_error:     call    show
   368                                  ;                db      "Error! Hit a key to reboot."
   369 0000014B 4572726F72212E                          db      "Error!."
   370                                  
   371 00000152 30E4                                    xor     ah,ah
   372 00000154 CD13                                    int     0x13                    ; reset floppy
   373 00000156 CD16                                    int     0x16                    ; wait for a key
   374 00000158 CD19                                    int     0x19                    ; reboot the machine
   375                                  
   376                                  
   377                                  ;       readDisk:       Reads a number of sectors into memory.
   378                                  ;
   379                                  ;       Call with:      DX:AX = 32-bit DOS sector number
   380                                  ;                       DI = number of sectors to read
   381                                  ;                       ES:BX = destination buffer
   382                                  ;
   383                                  ;       Returns:        CF set on error
   384                                  ;                       ES:BX points one byte after the last byte read.
   385                                  
   386 0000015A 56                      readDisk:       push    si
   387                                  
   388 0000015B 8946C8                                  mov     LBA_SECTOR_0,ax
   389 0000015E 8956CA                                  mov     LBA_SECTOR_16,dx
   390 00000161 8C869EE7                                mov     word [READADDR_SEG], es
   391 00000165 899E9CE7                                mov     word [READADDR_OFF], bx
   392                                  
   393 00000169 E8D0FF                                  call    show
   394 0000016C 2E                                      db      "."
   395                                  read_next:
   396                                  
   397                                  ;******************** LBA_READ *******************************
   398                                  
   399                                                                                  ; check for LBA support
   400                                                                                                                  
   401 0000016D B441                                    mov     ah,041h                 ;
   402 0000016F BBAA55                                  mov     bx,055aah               ;
   403 00000172 8A5624                                  mov     dl, [drive]
   404                                  
   405                                                  ; NOTE: sys must be updated if location changes!!!
   406 00000175 84D2                                    test    dl,dl                   ; don't use LBA addressing on A:
   407 00000177 7419                                    jz      read_normal_BIOS        ; might be a (buggy)
   408                                                                                  ; CDROM-BOOT floppy emulation
   409                                  
   410 00000179 CD13                                    int     0x13
   411 0000017B 7215                                    jc      read_normal_BIOS
   412                                  
   413 0000017D D1E9                                    shr     cx,1                    ; CX must have 1 bit set
   414                                  
   415 0000017F 81DB54AA                                sbb     bx,0aa55h - 1           ; tests for carry (from shr) too!
   416 00000183 750D                                    jne     read_normal_BIOS
   417                                                  
   418                                                                  
   419                                                                                  ; OK, drive seems to support LBA addressing
   420                                  
   421 00000185 8D76C0                                  lea     si,[LBA_PACKET]
   422                                                              
   423                                                                                  ; setup LBA disk block                                  
   424 00000188 895ECC                                  mov     LBA_SECTOR_32,bx        ; bx is 0 if extended 13h mode supported
   425 0000018B 895ECE                                  mov     LBA_SECTOR_48,bx
   426                                          
   427 0000018E B442                                    mov     ah,042h
   428 00000190 EB26                                    jmp short    do_int13_read
   429                                  
   430                                                                                          
   431                                  
   432                                  read_normal_BIOS:      
   433                                  
   434                                  ;******************** END OF LBA_READ ************************
   435 00000192 8B4EC8                                  mov     cx,LBA_SECTOR_0
   436 00000195 8B56CA                                  mov     dx,LBA_SECTOR_16
   437                                  
   438                                  
   439                                                  ;
   440                                                  ; translate sector number to BIOS parameters
   441                                                  ;
   442                                  
   443                                                  ;
   444                                                  ; abs = sector                          offset in track
   445                                                  ;     + head * sectPerTrack             offset in cylinder
   446                                                  ;     + track * sectPerTrack * nHeads   offset in platter
   447                                                  ;
   448 00000198 8A4618                                  mov     al, [sectPerTrack]
   449 0000019B F6661A                                  mul     byte [nHeads]
   450 0000019E 91                                      xchg    ax, cx
   451                                                  ; cx = nHeads * sectPerTrack <= 255*63
   452                                                  ; dx:ax = abs
   453 0000019F F7F1                                    div     cx
   454                                                  ; ax = track, dx = sector + head * sectPertrack
   455 000001A1 92                                      xchg    ax, dx
   456                                                  ; dx = track, ax = sector + head * sectPertrack
   457 000001A2 F67618                                  div     byte [sectPerTrack]
   458                                                  ; dx =  track, al = head, ah = sector
   459 000001A5 89D1                                    mov     cx, dx
   460                                                  ; cx =  track, al = head, ah = sector
   461                                  
   462                                                  ; the following manipulations are necessary in order to
   463                                                  ; properly place parameters into registers.
   464                                                  ; ch = cylinder number low 8 bits
   465                                                  ; cl = 7-6: cylinder high two bits
   466                                                  ;      5-0: sector
   467 000001A7 88C6                                    mov     dh, al                  ; save head into dh for bios
   468 000001A9 86E9                                    xchg    ch, cl                  ; set cyl no low 8 bits
   469 000001AB D0C9                                    ror     cl, 1                   ; move track high bits into
   470 000001AD D0C9                                    ror     cl, 1                   ; bits 7-6 (assumes top = 0)
   471 000001AF 08E1                                    or      cl, ah                  ; merge sector into cylinder
   472 000001B1 41                                      inc     cx                      ; make sector 1-based (1-63)
   473                                  
   474 000001B2 C45EC4                                  les     bx,[LBA_OFF]
   475 000001B5 B80102                                  mov     ax, 0x0201
   476                                  do_int13_read:                
   477 000001B8 8A5624                                  mov     dl, [drive]
   478 000001BB CD13                                    int     0x13
   479 000001BD 7289                                    jc      boot_error              ; exit on error
   480                                  
   481 000001BF 8B460B                                  mov     ax, word [bsBytesPerSec]  
   482                                  
   483 000001C2 57                                      push    di
   484 000001C3 BEA063                                  mov     si,READBUF              ; copy read in sector data to
   485 000001C6 C4BE9CE7                                les     di,[READADDR_OFF]       ; user provided buffer
   486 000001CA 89C1                                    mov     cx, ax
   487                                  ;                shr     cx, 1                   ; convert bytes to word count
   488                                  ;                rep     movsw
   489 000001CC F3A4                                    rep     movsb
   490 000001CE 5F                                      pop     di
   491                                  
   492                                  ;               div     byte[LBA_PACKET]        ; luckily 16 !!
   493 000001CF B104                                    mov     cl, 4
   494 000001D1 D3E8                                    shr     ax, cl                  ; adjust segment pointer by increasing
   495 000001D3 01869EE7                                add     word [READADDR_SEG], ax ; by paragraphs read in (per sector)
   496                                  
   497 000001D7 8346C801                                add     LBA_SECTOR_0,  byte 1
   498 000001DB 8356CA00                                adc     LBA_SECTOR_16, byte 0   ; DX:AX = next sector to read
   499 000001DF 4F                                      dec     di                      ; if there is anything left to read,
   500 000001E0 758B                                    jnz     read_next               ; continue
   501                                  
   502 000001E2 C49E9CE7                                les     bx, [READADDR_OFF]
   503                                                  ; clear carry: unnecessary since adc clears it
   504 000001E6 5E                                      pop     si
   505 000001E7 C3                                      ret
   506                                  
   507 000001E8 00<rept>                       times   0x01f1-$+$$ db 0
   508                                  
   509 000001F1 4B45524E454C202053-     filename        db      "KERNEL  SYS",0,0
   510 000001FA 59530000           
   511                                  
   512 000001FE 55AA                    sign            dw      0xAA55
   513                                  
   514                                  %ifdef DBGPRNNUM
   515                                  ; DEBUG print hex digit routines
   516                                  PrintLowNibble:         ; Prints low nibble of AL, AX is destroyed
   517                                          and  AL, 0Fh    ; ignore upper nibble
   518                                          cmp  AL, 09h    ; if greater than 9, then don't base on '0', base on 'A'
   519                                          jbe .printme
   520                                          add  AL, 7      ; convert to character A-F
   521                                          .printme:
   522                                          add  AL, '0'    ; convert to character 0-9
   523                                          mov  AH,0x0E    ; show character
   524                                          int  0x10       ; via "TTY" mode
   525                                          retn
   526                                  PrintAL:                ; Prints AL, AX is preserved
   527                                          push AX         ; store value so we can process a nibble at a time
   528                                          shr  AL, 4              ; move upper nibble into lower nibble
   529                                          call PrintLowNibble
   530                                          pop  AX         ; restore for other nibble
   531                                          push AX         ; but save so we can restore original AX
   532                                          call PrintLowNibble
   533                                          pop  AX         ; restore for other nibble
   534                                          retn
   535                                  PrintNumber:            ; Prints (in Hex) value in AX, AX is preserved
   536                                          xchg AH, AL     ; high byte 1st
   537                                          call PrintAL
   538                                          xchg AH, AL     ; now low byte
   539                                          call PrintAL
   540                                          retn
   541                                  %endif
   542                                  
